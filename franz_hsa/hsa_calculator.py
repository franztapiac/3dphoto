from pathlib import Path
from tools.DataSetGraph import ReadPolyData, WritePolyData
from Analyze3DPhotogram import PlaceLandmarks, ComputeHSAandRiskScore
from vtkmodules.util import numpy_support
import re
import pandas as pd
import os
import pyvista as pv
import datetime
import json
import random
random.seed(0)


def get_landmark_coordinates(landmarks_vtp):
    """Extract the landmark coordinates from a vtkPolyData object.

    Args:
        landmarks_vtp (vtkPolyData): The VTK PolyData object containing the landmarks.

    Returns:
        ndarray: A NumPy array with shape (n, 3) where each row contains the (x, y, z) coordinates of a landmark.
    """
    points = landmarks_vtp.GetPoints()
    dataArray = points.GetData()
    landmark_coordinates = numpy_support.vtk_to_numpy(dataArray)
    return landmark_coordinates


def load_hsa_scores(hsa_indices_xlsx_path):
    """
    Loads the hsa scores from the previously exported .xlsx file of hsa scores.
    :param hsa_indices_xlsx_path: a Path object to the .xlsx file containing the hsa data.
    :return: a dictionary with keys as subtypes, inner keys as mesh id numbers, and HSA indices as values.
    """

    hsa_indices_data = pd.read_excel(hsa_indices_xlsx_path, header=None)

    header = hsa_indices_data.iloc[0]
    subtypes_df = header[header.notna()]
    subtypes = subtypes_df.values.tolist()
    subtypes_cols = subtypes_df.index.tolist()

    hsa_scores = dict()

    for i, subtype in enumerate(subtypes):
        hsa_scores[subtype] = dict()
        mesh_ids = hsa_indices_data.iloc[2:, subtypes_cols[i]]
        mesh_ids = mesh_ids[mesh_ids.notna()].tolist()
        subtype_data = hsa_indices_data.iloc[2:, subtypes_cols[i]+1]
        subtype_data = subtype_data[subtype_data.notna()].tolist()
        subtype_data = [float(item) for item in subtype_data]
        for j, mesh_id in enumerate(mesh_ids):
            hsa_scores[subtype][mesh_id] = subtype_data[j]

    return hsa_scores


def export_to_excel(hsa_indices, output_path):
    """
    Exports the HSA indices for meshes of different subtypes.
    :param hsa_indices: a dictionary with keys as subtypes, inner keys as mesh id numbers, and HSA indices as values.
    :param output_path: a Path object to the .xlsx file to write the hsa indices data to.
    """

    with pd.ExcelWriter(str(output_path.absolute())) as writer:
        for i, subtype in enumerate(list(hsa_indices.keys())):
            print(f'Exporting {subtype}...')

            # Generating the dataframe from the dictionary
            size = len(hsa_indices.keys())
            df = pd.DataFrame.from_dict(hsa_indices[subtype], orient='index', columns=['HSA index'])
            df.to_excel(writer, sheet_name='Sheet1', startcol=i*(size+2), startrow=1, index=True)


def get_mesh_info(mesh_vtp_file_path):
    """
    Return the subtype and id number of a mesh from a Path object.
    :param mesh_vtp_file_path: a Path object of a .vtp mesh file.
    :return: the mesh subtype and id number.
    """

    pattern = r'^(.*?)_inst_(\d{3})_cp$'
    match = re.match(pattern, mesh_vtp_file_path.stem)
    mesh_subtype = match.group(1)
    mesh_id_num = int(match.group(2))

    return mesh_subtype, mesh_id_num


def export_landmarks_object(landmarks, mesh_file_path):
    """
    Exports the generated landmarks object in three formats: .ply, .vtk, and .vtp
    :param landmarks: a vtk object for the landmarks object generated by the published method
    :param mesh_file_path: a Path object for the file path to the considered mesh
    """
    extensions = ['.ply', '.vtp', '.vtk']
    for extension in extensions:
        landmarks_file_path = mesh_file_path.parent / 'predicted_landmarks_object' / (mesh_file_path.stem +
                                                                                      '_predicted_landmarks' +
                                                                                      extension)
        if not os.path.exists(landmarks_file_path.parent):
            os.makedirs(landmarks_file_path.parent)
        WritePolyData(landmarks, str(landmarks_file_path.absolute()))


def export_landmarks(landmarks, mesh_file_path, time_now=''):
    """
    Export images of the landmarks placed on the mesh.
    :param landmarks: the vtk object with the predicted landmarks.
    :param mesh_file_path: the Path object to the file path of the mesh
    :param time_now: the datetime of when the whole experiment was begun
    """

    landmark_coordinates = get_landmark_coordinates(landmarks)

    landmark_ply = pv.PolyData(landmark_coordinates)
    landmark_ply_path = mesh_file_path.parent / ('predicted_landmarks_ply' + time_now) / (mesh_file_path.stem +
                                                                                          '_pred_landmarks.ply')
    if not os.path.exists(landmark_ply_path.parent):
        os.makedirs(landmark_ply_path.parent)

    landmark_ply.save(str(landmark_ply_path))


def manually_visualise_landmarks(meshes_to_visualise, vis_control):
    """
    Creates a PyVista Plotter visual of a mesh and its HSA-predicted landmarks.
    :param meshes_to_visualise: a dictionary with mesh subtypes and a list of mesh id numbers to visualise
    """

    ply_synth_data_path = Path('./synth_data/ply')
    ply_landmarks_path = Path('./synth_data/vtp_python_ply_landmarks')

    if not vis_control:
        del meshes_to_visualise['control']

    for subtype in list(meshes_to_visualise.keys()):

        subtype_folder = ply_synth_data_path / subtype
        mesh_id_nums = meshes_to_visualise[subtype]
        landmarks_coordinates_dir = ply_landmarks_path / subtype

        for mesh_id_num in mesh_id_nums:
            zero_padded_id = str(mesh_id_num).zfill(3)
            mesh_file_path = list(subtype_folder.glob(f'*{zero_padded_id}_cp.ply'))[0]
            mesh_predicted_landmarks_path = list(landmarks_coordinates_dir.glob(f'*{zero_padded_id}_cp_pred_landmarks.ply'))[0]

            p = pv.Plotter()
            p.add_mesh(pv.read(str(mesh_file_path)))
            landmark_coordinates = pv.read(str(mesh_predicted_landmarks_path))
            p.add_points(landmark_coordinates, render_points_as_spheres=True, point_size=15, color='r')
            p.add_text('{}'.format(mesh_file_path.name), position='upper_right', color='k')
            p.view_xy()
            p.show()


def load_mesh_files_info(json_file_path):
    """
    Read the list of paths used in a test data set to create a dictionary of subtypes and mesh ids
    :param json_file_path: the Path object to the json file of the test dataset
    :return: a dictionary with subtypes as keys and a list of mesh id numbers as values
    """

    with open(json_file_path, "r") as file:
        json_data = file.read()
    paths_list = json.loads(json_data)

    mesh_id_per_subtype = dict()
    for i, path in enumerate(paths_list):
        pattern = r'\\([^\\]+)\\[^\\]+_(\d+)_'
        match = re.search(pattern, path)
        subtype = match.group(1)
        if subtype not in mesh_id_per_subtype:
            mesh_id_per_subtype[subtype] = []
        mesh_id = int(match.group(2))
        mesh_id_per_subtype[subtype].append(mesh_id)

    return mesh_id_per_subtype


def calculate_hsa_scores(vtp_data_path, hsa_exec_params):
    """
    This function computes the HSA indices for the synthetic data in the vtp path given the HSA execution parameters.
    :param vtp_data_path: a Path object to a directory with subtype subdirectories, each of which contains .vtp meshes.
    :param hsa_exec_params: a dictionary with execution parameters.
    :return: a dictionary of HSA indices for each mesh of the subtypes in the .vtp data path.
    """
    hsa_indices = dict()

    for subtype_folder in vtp_data_path.iterdir():

        hsa_indices[subtype_folder.name] = dict()

        for mesh_vtp_file_path in subtype_folder.glob('*_cp.vtp'):

            # Load mesh and get its info
            mesh = ReadPolyData(str(mesh_vtp_file_path))
            mesh_subtype, mesh_id_num = get_mesh_info(mesh_vtp_file_path)
            print(f'Working on {mesh_subtype} case #{mesh_id_num}...')

            # Place landmarks on mesh, compute its hsa index, and store
            landmarks, _ = PlaceLandmarks(mesh, crop=hsa_exec_params['crop'], verbose=True,
                                          crop_percentage=hsa_exec_params['crop_percentage'])

            if hsa_exec_params['calculate_hsa']:
                _, hsa_index = ComputeHSAandRiskScore(mesh, landmarks, hsa_exec_params['age'], hsa_exec_params['sex'],
                                                      verbose=False)
                hsa_indices[mesh_subtype][mesh_id_num] = hsa_index

    return hsa_indices


def measure_hsa_of_synth_data():
    """
    Run this to load onto memory the HSA indices of the synthetic data.
    Define the path to the existing data for loading, and to the synthetic data for execution.
    """

    hsa_scores_file_path = Path('hsa_scores.xlsx')

    if os.path.exists(hsa_scores_file_path):
        hsa_scores = load_hsa_scores(hsa_scores_file_path)
    else:
        vtp_format_synth_data_dir = Path('./synth_data/vtp_python')
        exec_time_label = datetime.datetime.now().strftime("%B_%d_%H_%M")
        hsa_execution_parameters = {'age': 200,
                                    'sex': 'M',
                                    'crop': False,
                                    'crop_percentage': 0,
                                    'calculate_hsa': False,
                                    'time_label_of_exec': exec_time_label}
        hsa_scores = calculate_hsa_scores(vtp_format_synth_data_dir, hsa_execution_parameters)
        export_to_excel(hsa_scores, output_path=hsa_scores_file_path)


def visualise_model_both_landmarks():
    """
    Run this to get a PyVista plotter showing a synthetic mesh with its predicted landmarks.
    The meshes shown are from the test dataset of the model trained with all subtypes.
    """
    model_both_test_data_path = Path('./synth_data/test_datasets/testdata_model_0108_both.json.json')
    dataset_meshes_ids = load_mesh_files_info(model_both_test_data_path)
    visualise_control = False
    manually_visualise_landmarks(dataset_meshes_ids, visualise_control)


def visualise_model_metopic_landmarks():
    """
    Run this to get a PyVista plotter showing a synthetic mesh with its predicted landmarks.
    The meshes shown are from the test dataset of the model trained only with control and metopic meshes.
    """
    model_both_test_data_path = Path('./synth_data/test_datasets/testdata_model_0108_metopicB.json.json')
    dataset_meshes_ids = load_mesh_files_info(model_both_test_data_path)
    visualise_control = False
    manually_visualise_landmarks(dataset_meshes_ids, visualise_control)


def visualise_model_sagittal_landmarks():
    """
    Run this to get a PyVista plotter showing a synthetic mesh with its predicted landmarks.
    The meshes shown are from the test dataset of the model trained only with control and sagittal meshes.
    """
    model_both_test_data_path = Path('./synth_data/test_datasets/testdata_model_0108_sagittalB.json.json')
    dataset_meshes_ids = load_mesh_files_info(model_both_test_data_path)
    visualise_control = False
    manually_visualise_landmarks(dataset_meshes_ids, visualise_control)


if __name__ == '__main__':
    visualise_model_sagittal_landmarks()

